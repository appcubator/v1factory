// Generated by CoffeeScript 1.4.0
(function() {
  var Deferred, PROMISE_API, Promise, async,
    __slice = [].slice;

  PROMISE_API = ['asap', 'then', 'always', 'done', 'fail', 'progress', 'timeout', 'pipe', 'when', 'status'];

  async = {
    debug: false,
    parallel: {
      forEach: function(array, callback) {
        return async.promise(function(p) {
          return p.resolve();
        });
      },
      map: function(array, callback) {
        return async.promise(function(p) {
          var done, result, total;
          result = [];
          total = 0;
          done = false;
          array.forEach(function(item, index) {
            total++;
            return async.when(callback(item, index, array)).done(function(item) {
              result[index] = item;
              total--;
              if (done && total === 0) {
                return p.resolve(result);
              }
            }).fail(function() {
              return p.reject.apply(p, arguments);
            });
          });
          done = true;
          if (total === 0) {
            return p.resolve(result);
          }
        });
      }
    },
    forEach: function(array, callback) {
      var sequence;
      sequence = async.when(true);
      array.forEach(function(item) {
        return sequence.when(function() {
          return callback(item);
        });
      });
      return sequence;
    },
    map: function(array, callback) {
      return async.promise(function(p) {
        var result, sequence;
        result = [];
        sequence = async.when(true);
        array.forEach(function(item, index) {
          return sequence = sequence.when(function() {
            return callback(item, index, array);
          }).done(function(v) {
            return result[index] = v;
          });
        });
        sequence.done(function() {
          return p.resolve(result);
        });
        return sequence.fail(function() {
          return p.reject.apply(p, arguments);
        });
      });
    },
    reduce: function(array, callback, initialValue) {
      var previousValue;
      previousValue = async.when(initialValue);
      array.forEach(function(item) {
        return previousValue = previousValue.when(function(prev) {
          return callback(prev, item);
        });
      });
      return previousValue;
    },
    some: function(array, callback) {
      var O, len;
      O = Object(array);
      len = O.length >>> 0;
      if (typeof fun === !"function") {
        throw new TypeError();
      }
      return async.promise(function(p) {
        var _next;
        _next = function(k) {
          var kValue;
          if (k >= len) {
            return p.resolve(false);
          }
          if (k in array) {
            kValue = array[k];
            return async.when(callback(kValue)).done(function(test) {
              if (test) {
                return p.resolve(true);
              } else {
                return _next(k + 1).fail(p.reject);
              }
            });
          } else {
            return _next(k + 1);
          }
        };
        return _next(0);
      });
    },
    detect: function(array, callback) {
      return async.promise(function(p) {
        return async.some(array, function(item) {
          return async.when(callback(item)).when(function(test) {
            if (test) {
              return p.resolve(item);
            }
          });
        }).done(function(test) {
          if (!test) {
            return p.resolve(false);
          }
        }).fail(p.resolve);
      });
    },
    defer: function() {
      return new Deferred();
    },
    promise: function(callback) {
      var deferred;
      deferred = async.defer();
      callback(deferred);
      return deferred.promise();
    },
    when: function(v) {
      var deferred;
      if (async.isPromise(v)) {
        return v;
      } else {
        deferred = async.defer();
        deferred.resolve(v);
        return deferred.promise();
      }
    },
    join: function() {
      var promises;
      promises = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return async.parallel.forEach(promises, function(item) {
        return item;
      });
    },
    isPromise: function(v) {
      return v && v.isPromise;
    }
  };

  Promise = (function() {

    function Promise() {}

    Promise.prototype.isPromise = true;

    return Promise;

  })();

  Deferred = (function() {

    function Deferred() {
      var cachedPromise, dirtyHandle, done, error, markDirty, notify, progressHandlers, rejected, resolved, resultHandlers, results, timeoutHandle,
        _this = this;
      progressHandlers = [];
      resultHandlers = [];
      results = [];
      done = resolved = rejected = false;
      cachedPromise = timeoutHandle = dirtyHandle = error = void 0;
      markDirty = function() {
        if (!done) {
          return;
        }
        if (dirtyHandle) {
          return;
        }
        return dirtyHandle = setTimeout(notify, 0);
      };
      notify = function() {
        var handler, _ref;
        if (!done) {
          throw new Error("Not done yet.");
        }
        if (dirtyHandle) {
          clearTimeout(dirtyHandle);
        }
        dirtyHandle = void 0;
        while (handler = resultHandlers.shift()) {
          try {
            if (handler.always || (rejected && handler.onReject)) {
              (_ref = handler.callback).call.apply(_ref, [_this, error].concat(__slice.call(results)));
            } else if (resolved && handler.onResolve) {
              handler.callback.apply(_this, results);
            }
          } catch (e) {
            if (async.debug) {
              setTimeout((function() {
                throw e;
              }), 0);
            } else {
              console.log("Failed to execute handler: %s", e);
            }
          }
        }
        return _this;
      };
      this.status = function() {
        if (resolved) {
          return "resolved";
        } else if (rejected) {
          return "rejected";
        } else {
          return "pending";
        }
      };
      this.inspect = function() {
        return "Promise status=" + (_this.status()) + ", error=" + error;
      };
      this.toJSON = function() {
        return {
          isPromise: true,
          status: _this.status(),
          error: error,
          results: results
        };
      };
      this.promise = function() {
        return cachedPromise || (cachedPromise = (function() {
          var result;
          result = new Promise();
          PROMISE_API.forEach(function(f) {
            return result[f] = _this[f];
          });
          result.inspect = function() {
            return "ViewOf" + this.inspect();
          };
          result.toJSON = _this.toJSON;
          return result;
        })());
      };
      this.asap = function() {
        var isAsap;
        isAsap = true;
        return _this;
      };
      this.then = this.always = function(callback) {
        resultHandlers.push({
          callback: callback,
          always: true
        });
        markDirty();
        return _this;
      };
      this.done = function(callback) {
        resultHandlers.push({
          callback: callback,
          onResolve: true
        });
        markDirty();
        return _this;
      };
      this.fail = function(callback) {
        resultHandlers.push({
          callback: callback,
          onReject: true
        });
        markDirty();
        return _this;
      };
      this.progress = function(callback) {
        progressHandlers.push({
          callback: callback
        });
        return _this;
      };
      this.timeout = function(delay) {
        var timeout;
        if (timeoutHandle) {
          clearTimeout(timeoutHandle);
        }
        timeout = function() {
          if (!(done && timeoutHandle)) {
            return _this.reject("time-out: " + delay + "ms");
          }
        };
        timeoutHandle = setTimeout(timeout, delay);
        return _this.always(function() {
          return clearTimeout(timeoutHandle);
        });
      };
      this.pipe = function(promise) {
        _this.done(function() {
          return promise.resolve.apply(promise, arguments);
        });
        return _this.fail(function() {
          return promise.reject.apply(promise, arguments);
        });
      };
      this.when = function(callback) {
        return async.promise(function(p) {
          _this.fail(function() {
            return p.reject.apply(p, arguments);
          });
          return _this.done(function() {
            var result;
            try {
              result = callback.apply(null, arguments);
            } catch (e) {
              console.log(e.stack);
              return p.reject(e);
            }
            if (async.isPromise(result)) {
              return result.pipe(p);
            } else {
              return p.resolve(result);
            }
          });
        });
      };
      this.drain = function(other) {
        if (async.isPromise(other)) {
          return other.pipe(_this);
        } else {
          return _this.resolve(other);
        }
      };
      this.reject = function() {
        var _error, _results;
        _error = arguments[0], _results = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (done) {
          throw new Error("Promise was already done.");
        }
        done = rejected = true;
        error = _error;
        results = _results;
        notify();
        return _this;
      };
      this.resolve = function() {
        var _results;
        _results = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (done) {
          throw new Error("Promise was already done.");
        }
        done = resolved = true;
        results = _results;
        notify();
        return _this;
      };
      this.node = function() {
        var args, error;
        error = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (error) {
          return _this.reject.apply(_this, arguments);
        } else {
          return _this.resolve.apply(_this, args);
        }
      };
      this.now = function() {
        notify();
        return _this;
      };
      this.tryUnwrap = function() {
        now();
        if (done) {
          return _this["eval"]();
        } else {
          return _this;
        }
      };
      this["eval"] = function() {
        if (resolved) {
          return _results[0];
        } else if (rejected) {
          throw error;
        } else {
          throw new Error("This Promise wasn't resolved yet.");
        }
      };
    }

    Deferred;


    return Deferred;

  })();

  module.exports = async;

  /*
  
  delay = (timespan, action) ->
    async.promise (p) ->
      later = ->
        p.resolve(action())
      setTimeout(later, timespan)
  
  aPost = ->
    return {
      getAuthor: ->
        async.promise (p) ->
          setTimeout(
            (-> p.resolve({ name: "Albert" })),
            0
          )
    }
  
  getPosts = ->
    async.promise (p) ->
      setTimeout(
        (-> p.resolve([aPost()])),
        10
      )
  
  reducer = (prev, next) ->
    if next == 0 then throw new Error("Division by zero.")
    delay 0, -> prev / next
  
  async.reduce([2, 5, 10], reducer, 100).done(-> console.log arguments)
  async.reduce([2, 5,  0], reducer, 100).fail(-> console.log arguments)
  
  mapper = ->
    called = 0
    (item, index, array) ->
      delay 10 * (array.length - index), -> called++
  
  async.map([1,1,1], mapper()).always(-> console.log "Sequential: %j", arguments)
  async.parallel.map([1,1,1], mapper()).always(-> console.log "Parallel: %j", arguments)
  
  detector = (item) ->
    delay 0, -> item % 42 == 0
  
  async.some([1,5,7], detector).always(console.log)
  async.some([1,5,42], detector).always(console.log)
  async.detect([1,5,7], detector).always(console.log)
  async.detect([1,5,84], detector).always(console.log)
  
  getPosts()
    .done(-> console.log "Received posts.")
    .when((posts) -> posts[0].getAuthor())
    .done(-> console.log "Received author.")
    .when((author) -> author.name)
    .done((name) -> console.log "Name: %s", name)
    .timeout(500)
    .fail((e) -> console.log "Failed: %s.", e)
    .done(-> console.log "Success.")
  */


}).call(this);
